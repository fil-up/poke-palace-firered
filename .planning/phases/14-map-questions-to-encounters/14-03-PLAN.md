---
phase: 14-map-questions-to-encounters
plan: 03
type: execute
wave: 3
depends_on: ["14-02"]
files_modified:
  - pokefirered/src/quiz/quiz.c
  - pokefirered/include/quiz/quiz.h
autonomous: true

must_haves:
  truths:
    - "Gym battles pull questions from all prior area species"
    - "Area pool is built dynamically based on gym index"
    - "Each gym has access to progressively more species' questions"
  artifacts:
    - path: "pokefirered/src/quiz/quiz.c"
      provides: "Dynamic area pool building by gym"
      contains: "Quiz_BuildAreaPoolForGym"
    - path: "pokefirered/include/quiz/quiz.h"
      provides: "Gym area mapping declarations (if needed)"
  key_links:
    - from: "pokefirered/src/quiz/quiz.c"
      to: "gWildMonHeaders"
      via: "Wild encounter data lookup"
      pattern: "gWildMonHeaders"
    - from: "pokefirered/src/quiz/quiz.c"
      to: "Quiz_GetBank"
      via: "Species bank lookup"
      pattern: "Quiz_GetBank"
---

<objective>
Implement dynamic area pool building for gym battles based on prior traversed areas.

Purpose: Currently Quiz_BuildAreaPool() is hardcoded for Route 1/Viridian Forest/Route 2. With full game coverage, each gym needs to aggregate questions from ALL areas the player has traversed before reaching that gym. This plan creates a data-driven approach.

Output: Quiz_BuildAreaPool() replaced with dynamic gym-based lookup that aggregates species from prior areas.
</objective>

<execution_context>
@C:\Users\phill\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\phill\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-map-questions-to-encounters/14-RESEARCH.md
@.planning/phases/14-map-questions-to-encounters/14-01-SUMMARY.md
@.planning/phases/14-map-questions-to-encounters/14-02-SUMMARY.md

@pokefirered/src/quiz/quiz.c
@pokefirered/src/data/wild_encounters.json
@pokefirered/include/constants/map_groups.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gym-to-prior-areas mapping table</name>
  <files>pokefirered/src/quiz/quiz.c</files>
  <action>
Add a data table mapping each gym to the maps the player would have traversed before reaching it.

After the includes section in quiz.c, add:

```c
// ============================================
// Gym Area Progression Tables
// ============================================

// Maps accessible before each gym leader
// Brock (Pewter): Route 1, Viridian Forest, Route 2, Route 22
static const u16 sBrockGymAreas[] = {
    MAP_ROUTE1,
    MAP_VIRIDIAN_FOREST,
    MAP_ROUTE2,
    MAP_ROUTE22,
};

// Misty (Cerulean): Prior + Route 3, Mt Moon, Route 4, Route 24, Route 25
static const u16 sMistyGymAreas[] = {
    MAP_ROUTE1, MAP_VIRIDIAN_FOREST, MAP_ROUTE2, MAP_ROUTE22,
    MAP_ROUTE3, MAP_MT_MOON_1F, MAP_MT_MOON_B1F, MAP_MT_MOON_B2F,
    MAP_ROUTE4, MAP_ROUTE24, MAP_ROUTE25,
};

// Lt. Surge (Vermilion): Prior + Route 5, Route 6, Route 11, Diglett's Cave
static const u16 sSurgeGymAreas[] = {
    MAP_ROUTE1, MAP_VIRIDIAN_FOREST, MAP_ROUTE2, MAP_ROUTE22,
    MAP_ROUTE3, MAP_MT_MOON_1F, MAP_MT_MOON_B1F, MAP_MT_MOON_B2F,
    MAP_ROUTE4, MAP_ROUTE24, MAP_ROUTE25,
    MAP_ROUTE5, MAP_ROUTE6, MAP_ROUTE11, MAP_DIGLETTS_CAVE,
};

// Erika (Celadon): Prior + Route 7, Route 8, Route 9, Route 10, Rock Tunnel
static const u16 sErikaGymAreas[] = {
    MAP_ROUTE1, MAP_VIRIDIAN_FOREST, MAP_ROUTE2, MAP_ROUTE22,
    MAP_ROUTE3, MAP_MT_MOON_1F, MAP_MT_MOON_B1F, MAP_MT_MOON_B2F,
    MAP_ROUTE4, MAP_ROUTE24, MAP_ROUTE25,
    MAP_ROUTE5, MAP_ROUTE6, MAP_ROUTE11, MAP_DIGLETTS_CAVE,
    MAP_ROUTE7, MAP_ROUTE8, MAP_ROUTE9, MAP_ROUTE10, 
    MAP_ROCK_TUNNEL_1F, MAP_ROCK_TUNNEL_B1F,
};

// Koga (Fuchsia): Prior + Route 12, Route 13, Route 14, Route 15, Safari Zone
static const u16 sKogaGymAreas[] = {
    MAP_ROUTE1, MAP_VIRIDIAN_FOREST, MAP_ROUTE2, MAP_ROUTE22,
    MAP_ROUTE3, MAP_MT_MOON_1F, MAP_MT_MOON_B1F, MAP_MT_MOON_B2F,
    MAP_ROUTE4, MAP_ROUTE24, MAP_ROUTE25,
    MAP_ROUTE5, MAP_ROUTE6, MAP_ROUTE11, MAP_DIGLETTS_CAVE,
    MAP_ROUTE7, MAP_ROUTE8, MAP_ROUTE9, MAP_ROUTE10,
    MAP_ROCK_TUNNEL_1F, MAP_ROCK_TUNNEL_B1F,
    MAP_ROUTE12, MAP_ROUTE13, MAP_ROUTE14, MAP_ROUTE15,
    MAP_SAFARI_ZONE_CENTER, MAP_SAFARI_ZONE_EAST,
    MAP_SAFARI_ZONE_NORTH, MAP_SAFARI_ZONE_WEST,
};

// Sabrina (Saffron): Same as Koga (accessible around same time)
static const u16 sSabrinaGymAreas[] = {
    MAP_ROUTE1, MAP_VIRIDIAN_FOREST, MAP_ROUTE2, MAP_ROUTE22,
    MAP_ROUTE3, MAP_MT_MOON_1F, MAP_MT_MOON_B1F, MAP_MT_MOON_B2F,
    MAP_ROUTE4, MAP_ROUTE24, MAP_ROUTE25,
    MAP_ROUTE5, MAP_ROUTE6, MAP_ROUTE11, MAP_DIGLETTS_CAVE,
    MAP_ROUTE7, MAP_ROUTE8, MAP_ROUTE9, MAP_ROUTE10,
    MAP_ROCK_TUNNEL_1F, MAP_ROCK_TUNNEL_B1F,
    MAP_ROUTE12, MAP_ROUTE13, MAP_ROUTE14, MAP_ROUTE15,
    MAP_POKEMON_TOWER_3F, MAP_POKEMON_TOWER_4F,
    MAP_POKEMON_TOWER_5F, MAP_POKEMON_TOWER_6F, MAP_POKEMON_TOWER_7F,
};

// Blaine (Cinnabar): Prior + Route 19, Route 20, Route 21, Seafoam, Pokemon Mansion
static const u16 sBlaineGymAreas[] = {
    MAP_ROUTE1, MAP_VIRIDIAN_FOREST, MAP_ROUTE2, MAP_ROUTE22,
    MAP_ROUTE3, MAP_MT_MOON_1F, MAP_MT_MOON_B1F, MAP_MT_MOON_B2F,
    MAP_ROUTE4, MAP_ROUTE24, MAP_ROUTE25,
    MAP_ROUTE5, MAP_ROUTE6, MAP_ROUTE11, MAP_DIGLETTS_CAVE,
    MAP_ROUTE7, MAP_ROUTE8, MAP_ROUTE9, MAP_ROUTE10,
    MAP_ROCK_TUNNEL_1F, MAP_ROCK_TUNNEL_B1F,
    MAP_ROUTE12, MAP_ROUTE13, MAP_ROUTE14, MAP_ROUTE15,
    MAP_SAFARI_ZONE_CENTER, MAP_SAFARI_ZONE_EAST,
    MAP_SAFARI_ZONE_NORTH, MAP_SAFARI_ZONE_WEST,
    MAP_ROUTE19, MAP_ROUTE20, MAP_ROUTE21,
    MAP_SEAFOAM_ISLANDS_1F, MAP_SEAFOAM_ISLANDS_B1F,
    MAP_SEAFOAM_ISLANDS_B2F, MAP_SEAFOAM_ISLANDS_B3F, MAP_SEAFOAM_ISLANDS_B4F,
    MAP_POKEMON_MANSION_1F, MAP_POKEMON_MANSION_2F,
    MAP_POKEMON_MANSION_3F, MAP_POKEMON_MANSION_B1F,
};

// Giovanni (Viridian): Prior + Victory Road (final gym, all areas)
static const u16 sGiovanniGymAreas[] = {
    MAP_ROUTE1, MAP_VIRIDIAN_FOREST, MAP_ROUTE2, MAP_ROUTE22,
    MAP_ROUTE3, MAP_MT_MOON_1F, MAP_MT_MOON_B1F, MAP_MT_MOON_B2F,
    MAP_ROUTE4, MAP_ROUTE24, MAP_ROUTE25,
    MAP_ROUTE5, MAP_ROUTE6, MAP_ROUTE11, MAP_DIGLETTS_CAVE,
    MAP_ROUTE7, MAP_ROUTE8, MAP_ROUTE9, MAP_ROUTE10,
    MAP_ROCK_TUNNEL_1F, MAP_ROCK_TUNNEL_B1F,
    MAP_ROUTE12, MAP_ROUTE13, MAP_ROUTE14, MAP_ROUTE15,
    MAP_SAFARI_ZONE_CENTER, MAP_SAFARI_ZONE_EAST,
    MAP_SAFARI_ZONE_NORTH, MAP_SAFARI_ZONE_WEST,
    MAP_ROUTE19, MAP_ROUTE20, MAP_ROUTE21,
    MAP_SEAFOAM_ISLANDS_1F, MAP_SEAFOAM_ISLANDS_B1F,
    MAP_SEAFOAM_ISLANDS_B2F, MAP_SEAFOAM_ISLANDS_B3F, MAP_SEAFOAM_ISLANDS_B4F,
    MAP_POKEMON_MANSION_1F, MAP_POKEMON_MANSION_2F,
    MAP_POKEMON_MANSION_3F, MAP_POKEMON_MANSION_B1F,
    MAP_ROUTE23, MAP_VICTORY_ROAD_1F, MAP_VICTORY_ROAD_2F, MAP_VICTORY_ROAD_3F,
};

// Gym area table structure
struct GymAreaTable {
    const u16 *maps;
    u8 mapCount;
};

static const struct GymAreaTable sGymAreaTables[] = {
    [0] = { sBrockGymAreas,    ARRAY_COUNT(sBrockGymAreas) },    // Brock
    [1] = { sMistyGymAreas,    ARRAY_COUNT(sMistyGymAreas) },    // Misty
    [2] = { sSurgeGymAreas,    ARRAY_COUNT(sSurgeGymAreas) },    // Lt. Surge
    [3] = { sErikaGymAreas,    ARRAY_COUNT(sErikaGymAreas) },    // Erika
    [4] = { sKogaGymAreas,     ARRAY_COUNT(sKogaGymAreas) },     // Koga
    [5] = { sSabrinaGymAreas,  ARRAY_COUNT(sSabrinaGymAreas) },  // Sabrina
    [6] = { sBlaineGymAreas,   ARRAY_COUNT(sBlaineGymAreas) },   // Blaine
    [7] = { sGiovanniGymAreas, ARRAY_COUNT(sGiovanniGymAreas) }, // Giovanni
};

#define NUM_GYMS 8
```

Include the map constants header if not already included:
```c
#include "constants/map_groups.h"
```
  </action>
  <verify>
- `grep "sGymAreaTables" pokefirered/src/quiz/quiz.c` returns matches
- Tables compile without unknown MAP_* constants
- `make` succeeds
  </verify>
  <done>
Gym-to-prior-areas mapping tables defined for all 8 gyms with appropriate map constants.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement dynamic area pool building functions</name>
  <files>pokefirered/src/quiz/quiz.c</files>
  <action>
Replace the hardcoded Quiz_BuildAreaPool() with dynamic gym-based lookup.

1. **Add helper function** to get species from a map's wild encounters:

```c
// Add species from a map's wild encounters to the pool
// Returns updated count
static u8 Quiz_AddMapSpeciesToPool(u16 mapId, u8 count)
{
    const struct WildPokemonHeader *header;
    const struct WildPokemonInfo *info;
    const struct WildPokemon *mon;
    u8 i;
    
    // Find the wild encounter header for this map
    for (header = gWildMonHeaders; header->mapGroup != MAP_GROUP(MAP_UNDEFINED); header++)
    {
        if (header->mapGroup == MAP_GROUP(mapId) && header->mapNum == MAP_NUM(mapId))
        {
            // Add land mons
            if (header->landMonsInfo != NULL)
            {
                info = header->landMonsInfo;
                for (i = 0; i < LAND_WILD_COUNT; i++)
                {
                    mon = &info->wildPokemon[i];
                    count = Quiz_AddBankToPool(Quiz_GetBank(mon->species), count);
                }
            }
            
            // Add water mons
            if (header->waterMonsInfo != NULL)
            {
                info = header->waterMonsInfo;
                for (i = 0; i < WATER_WILD_COUNT; i++)
                {
                    mon = &info->wildPokemon[i];
                    count = Quiz_AddBankToPool(Quiz_GetBank(mon->species), count);
                }
            }
            
            // Add fishing mons
            if (header->fishingMonsInfo != NULL)
            {
                info = header->fishingMonsInfo;
                for (i = 0; i < FISH_WILD_COUNT; i++)
                {
                    mon = &info->wildPokemon[i];
                    count = Quiz_AddBankToPool(Quiz_GetBank(mon->species), count);
                }
            }
            
            break;
        }
    }
    
    return count;
}
```

2. **Add gym index detection** (or accept as parameter):

```c
// Get gym index from current battle trainer
// Returns 0-7 for gym leaders, -1 if not a gym battle
static s8 Quiz_GetCurrentGymIndex(void)
{
    u16 trainerId = gTrainerBattleOpponent_A;
    
    // Map trainer IDs to gym indices
    // These are the gym leader trainer IDs from trainers.h
    switch (trainerId)
    {
    case TRAINER_BROCK:     return 0;
    case TRAINER_MISTY:     return 1;
    case TRAINER_LT_SURGE:  return 2;
    case TRAINER_ERIKA:     return 3;
    case TRAINER_KOGA:      return 4;
    case TRAINER_SABRINA:   return 5;
    case TRAINER_BLAINE:    return 6;
    case TRAINER_GIOVANNI:  return 7;
    default:                return -1;
    }
}
```

3. **Replace Quiz_BuildAreaPool()** with dynamic version:

```c
// Build aggregate question pool from all maps prior to current gym
// Returns number of questions added to the pool
static u8 Quiz_BuildAreaPool(void)
{
    s8 gymIndex;
    const struct GymAreaTable *areaTable;
    u8 count = 0;
    u8 i;
    
    gymIndex = Quiz_GetCurrentGymIndex();
    
    // If not a gym battle or unknown gym, fall back to full pool
    if (gymIndex < 0 || gymIndex >= NUM_GYMS)
        return Quiz_BuildFullPool();
    
    areaTable = &sGymAreaTables[gymIndex];
    
    // Add species from each map in the gym's area list
    for (i = 0; i < areaTable->mapCount; i++)
    {
        count = Quiz_AddMapSpeciesToPool(areaTable->maps[i], count);
    }
    
    // If we somehow got 0 questions, fall back to full pool
    if (count == 0)
        return Quiz_BuildFullPool();
    
    return count;
}
```

4. **Add required includes**:
```c
#include "wild_encounter.h"  // For gWildMonHeaders, WildPokemonHeader, etc.
#include "constants/trainers.h"  // For TRAINER_BROCK, etc.
```

5. **Verify duplicate handling**: Quiz_AddBankToPool already handles NULL banks, but the same species might appear multiple times in different encounter slots. The pool allows duplicates (they get shuffled and removed as used). This is acceptable - it means common species have more representation.

6. Build and test:
```bash
cd pokefirered && make -j4
```
  </action>
  <verify>
- `grep "Quiz_BuildAreaPool" pokefirered/src/quiz/quiz.c` shows new dynamic implementation
- `grep "Quiz_AddMapSpeciesToPool" pokefirered/src/quiz/quiz.c` shows helper function
- `grep "Quiz_GetCurrentGymIndex" pokefirered/src/quiz/quiz.c` shows gym detection
- Hardcoded species list (SPECIES_RATTATA, SPECIES_PIDGEY, etc.) no longer in Quiz_BuildAreaPool
- `make` succeeds without errors
  </verify>
  <done>
Quiz_BuildAreaPool() dynamically aggregates species from prior areas based on gym index, replacing hardcoded species list.
  </done>
</task>

</tasks>

<verification>
1. Gym area tables defined for all 8 gyms (Brock through Giovanni)
2. Quiz_AddMapSpeciesToPool() iterates wild encounter data for a map
3. Quiz_BuildAreaPool() uses gym index to select appropriate area table
4. Hardcoded species list removed from Quiz_BuildAreaPool()
5. Falls back to full pool if gym index unknown
6. Project builds without errors
</verification>

<success_criteria>
- [ ] Gym area progression tables defined for 8 gyms
- [ ] Quiz_AddMapSpeciesToPool() helper function created
- [ ] Quiz_GetCurrentGymIndex() returns correct gym index
- [ ] Quiz_BuildAreaPool() uses dynamic lookup instead of hardcoded list
- [ ] `make` succeeds
- [ ] Gym battles have access to progressively more questions based on progression
</success_criteria>

<output>
After completion, create `.planning/phases/14-map-questions-to-encounters/14-03-SUMMARY.md`
</output>
