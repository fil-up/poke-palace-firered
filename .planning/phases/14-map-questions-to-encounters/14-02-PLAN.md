---
phase: 14-map-questions-to-encounters
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - pokefirered/include/global.h
  - pokefirered/include/quiz/quiz.h
  - pokefirered/src/quiz/quiz.c
autonomous: true

must_haves:
  truths:
    - "Save data tracks species cleared status per-section (8 sections)"
    - "Save data tracks mastery progress per-section"
    - "Old V1 saves migrate to V2 format without data loss"
    - "Quiz_IsSpeciesClearedInSection(species, section) correctly checks section-specific status"
  artifacts:
    - path: "pokefirered/include/global.h"
      provides: "QuizSaveDataV2 struct definition"
      contains: "struct QuizSaveDataV2"
    - path: "pokefirered/include/quiz/quiz.h"
      provides: "Section-aware accessor declarations"
      contains: "Quiz_IsSpeciesClearedInSection"
    - path: "pokefirered/src/quiz/quiz.c"
      provides: "Section-aware accessor implementations"
      contains: "Quiz_GetMasteryMaskInSection"
  key_links:
    - from: "pokefirered/src/quiz/quiz.c"
      to: "pokefirered/include/global.h"
      via: "gSaveBlock1Ptr->quizDataV2"
      pattern: "gSaveBlock1Ptr->quizDataV2"
    - from: "pokefirered/src/quiz/quiz.c"
      to: "pokefirered/include/quiz/section_config.h"
      via: "QUIZ_NUM_SECTIONS constant"
      pattern: "QUIZ_NUM_SECTIONS"
---

<objective>
Expand save data structure to support section-aware cleared/mastery tracking.

Purpose: Enable species to be re-captured across sections by tracking cleared and mastery status per-section rather than globally. Uses the 400-byte unused_348C space in SaveBlock1.

Output:
- QuizSaveDataV2 struct (386 bytes) at unused_348C location
- Section-aware accessor functions (GetMasteryMaskInSection, SetMasteryMaskInSection, etc.)
- V1 to V2 migration function for existing saves
</objective>

<execution_context>
@C:\Users\phill\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\phill\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-map-questions-to-encounters/14-RESEARCH.md
@pokefirered/include/global.h
@pokefirered/include/quiz/quiz.h
@pokefirered/src/quiz/quiz.c
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define QuizSaveDataV2 struct in global.h</name>
  <files>pokefirered/include/global.h</files>
  <action>
Modify global.h to add the new save data structure:

1. Find the existing QuizSaveData struct (around line 647) and QuizSpeciesSave struct.

2. Add the new V2 structure BEFORE the existing structs (or replace if cleaner):
```c
// Section-aware quiz save data (V2)
// Total: 386 bytes - fits in unused_348C (400 bytes)
#define QUIZ_CLEARED_BYTES_PER_SECTION 20  // 160 species as bits
#define QUIZ_MASTERY_SLOTS_PER_SECTION 28  // Modulo-28 for mastery

struct QuizSaveDataV2
{
    u8 version;                                         // 1 byte - format version (2)
    u8 currentSection;                                  // 1 byte - cached current section
    u8 sectionCleared[8][QUIZ_CLEARED_BYTES_PER_SECTION];  // 160 bytes - cleared bits per section
    u8 masteryMask[8][QUIZ_MASTERY_SLOTS_PER_SECTION];     // 224 bytes - mastery per section
};  // Total: 386 bytes
```

3. In SaveBlock1 struct, find `/*0x348C*/ u8 unused_348C[400];` and replace with:
```c
    /*0x348C*/ struct QuizSaveDataV2 quizDataV2;  // Section-aware quiz data (386 bytes)
    /*0x360A*/ u8 unused_360A[14];                // Remaining padding (400 - 386 = 14 bytes)
```

4. Keep the old quizData field at 0x3A94 for now (migration reads from it). Mark it with a comment:
```c
    /*0x3A94*/ struct QuizSaveData quizData;  // DEPRECATED - V1 quiz data, kept for migration
```

5. Add STATIC_ASSERT to verify size:
```c
STATIC_ASSERT(sizeof(struct QuizSaveDataV2) <= 400, QuizSaveDataV2TooLarge);
```
  </action>
  <verify>Build compiles: `cd pokefirered && make -j4 2>&1 | grep -E "(error|warning.*quizData)" | head -10`</verify>
  <done>QuizSaveDataV2 struct defined at unused_348C location, STATIC_ASSERT confirms size fits</done>
</task>

<task type="auto">
  <name>Task 2: Add section-aware accessor declarations to quiz.h</name>
  <files>pokefirered/include/quiz/quiz.h</files>
  <action>
Add new function declarations to quiz.h:

1. Add include for section_config.h at top:
```c
#include "quiz/section_config.h"
```

2. Add new section-aware save data functions after existing save data functions:
```c
// Section-aware save data functions (V2)
void Quiz_InitSaveDataV2(void);
void Quiz_MigrateSaveData(void);
u8 Quiz_GetMasteryMaskInSection(u16 species, u8 section);
void Quiz_SetMasteryMaskInSection(u16 species, u8 section, u8 mask);
u8 Quiz_GetSpeciesStateInSection(u16 species, u8 section);
void Quiz_SetSpeciesStateInSection(u16 species, u8 section, u8 state);
bool8 Quiz_IsSpeciesClearedInSection(u16 species, u8 section);
void Quiz_SetSpeciesClearedInSection(u16 species, u8 section, bool8 cleared);
```

3. Update comment on existing functions to note they now use current section:
```c
// Save data functions (use current section internally)
```
  </action>
  <verify>Header compiles: `cd pokefirered && make -j4 2>&1 | grep -i error | head -5`</verify>
  <done>quiz.h declares all section-aware accessor functions</done>
</task>

<task type="auto">
  <name>Task 3: Implement section-aware accessors in quiz.c</name>
  <files>pokefirered/src/quiz/quiz.c</files>
  <action>
Add implementations to quiz.c:

1. Add include at top:
```c
#include "quiz/section_config.h"
```

2. Implement Quiz_InitSaveDataV2():
```c
void Quiz_InitSaveDataV2(void)
{
    u8 i, j;
    
    gSaveBlock1Ptr->quizDataV2.version = 2;
    gSaveBlock1Ptr->quizDataV2.currentSection = 1;
    
    // Clear all section data
    for (i = 0; i < QUIZ_NUM_SECTIONS; i++)
    {
        for (j = 0; j < QUIZ_CLEARED_BYTES_PER_SECTION; j++)
            gSaveBlock1Ptr->quizDataV2.sectionCleared[i][j] = 0;
        for (j = 0; j < QUIZ_MASTERY_SLOTS_PER_SECTION; j++)
            gSaveBlock1Ptr->quizDataV2.masteryMask[i][j] = 0;
    }
}
```

3. Implement Quiz_MigrateSaveData():
```c
void Quiz_MigrateSaveData(void)
{
    u8 version = gSaveBlock1Ptr->quizDataV2.version;
    
    if (version == 0 || version == 1)
    {
        // Initialize V2 structure
        Quiz_InitSaveDataV2();
        
        // Note: We lose old mastery data during migration since
        // V1 used species-indexed slots and V2 uses section+species.
        // This is acceptable - player starts fresh on section system.
        
        gSaveBlock1Ptr->quizDataV2.version = 2;
    }
}
```

4. Implement section-aware cleared status using bit arrays:
```c
bool8 Quiz_IsSpeciesClearedInSection(u16 species, u8 section)
{
    u8 byteIndex, bitIndex;
    
    if (section == 0 || section > QUIZ_NUM_SECTIONS)
        return FALSE;
    if (species == 0 || species >= 160)  // Only track first 160 species
        return FALSE;
    
    byteIndex = species / 8;
    bitIndex = species % 8;
    
    return (gSaveBlock1Ptr->quizDataV2.sectionCleared[section - 1][byteIndex] >> bitIndex) & 1;
}

void Quiz_SetSpeciesClearedInSection(u16 species, u8 section, bool8 cleared)
{
    u8 byteIndex, bitIndex;
    
    if (section == 0 || section > QUIZ_NUM_SECTIONS)
        return;
    if (species == 0 || species >= 160)
        return;
    
    byteIndex = species / 8;
    bitIndex = species % 8;
    
    if (cleared)
        gSaveBlock1Ptr->quizDataV2.sectionCleared[section - 1][byteIndex] |= (1 << bitIndex);
    else
        gSaveBlock1Ptr->quizDataV2.sectionCleared[section - 1][byteIndex] &= ~(1 << bitIndex);
}
```

5. Implement section-aware mastery (using modulo-28 slots):
```c
u8 Quiz_GetMasteryMaskInSection(u16 species, u8 section)
{
    u8 slot;
    
    if (section == 0 || section > QUIZ_NUM_SECTIONS)
        return 0;
    
    slot = species % QUIZ_MASTERY_SLOTS_PER_SECTION;
    return gSaveBlock1Ptr->quizDataV2.masteryMask[section - 1][slot];
}

void Quiz_SetMasteryMaskInSection(u16 species, u8 section, u8 mask)
{
    u8 slot;
    
    if (section == 0 || section > QUIZ_NUM_SECTIONS)
        return;
    
    slot = species % QUIZ_MASTERY_SLOTS_PER_SECTION;
    gSaveBlock1Ptr->quizDataV2.masteryMask[section - 1][slot] = mask;
}
```

6. Implement species state from cleared status:
```c
u8 Quiz_GetSpeciesStateInSection(u16 species, u8 section)
{
    // In V2, state is derived from cleared status
    // CLEARED if bit set, otherwise NONE (mastering handled separately)
    if (Quiz_IsSpeciesClearedInSection(species, section))
        return QUIZ_STATE_CLEARED;
    return QUIZ_STATE_NONE;
}

void Quiz_SetSpeciesStateInSection(u16 species, u8 section, u8 state)
{
    // In V2, only track CLEARED state via bit
    // Other states are runtime-only
    if (state == QUIZ_STATE_CLEARED)
        Quiz_SetSpeciesClearedInSection(species, section, TRUE);
}
```

7. Update existing global accessor functions to use current section:
```c
// Update Quiz_GetMasteryMask to use current section
u8 Quiz_GetMasteryMask(u16 species)
{
    u8 section = Quiz_GetCurrentSection();
    return Quiz_GetMasteryMaskInSection(species, section);
}

// Update Quiz_SetMasteryMask to use current section
void Quiz_SetMasteryMask(u16 species, u8 mask)
{
    u8 section = Quiz_GetCurrentSection();
    Quiz_SetMasteryMaskInSection(species, section, mask);
}

// Update Quiz_GetSpeciesState to use current section
u8 Quiz_GetSpeciesState(u16 species)
{
    u8 section = Quiz_GetCurrentSection();
    return Quiz_GetSpeciesStateInSection(species, section);
}

// Update Quiz_SetSpeciesState to use current section
void Quiz_SetSpeciesState(u16 species, u8 state)
{
    u8 section = Quiz_GetCurrentSection();
    Quiz_SetSpeciesStateInSection(species, section, state);
}

// Update Quiz_IsSpeciesCleared to use current section
bool8 Quiz_IsSpeciesCleared(u16 species)
{
    u8 section = Quiz_GetCurrentSection();
    return Quiz_IsSpeciesClearedInSection(species, section);
}
```

8. Update Quiz_InitSaveData to call V2 init:
```c
void Quiz_InitSaveData(void)
{
    Quiz_InitSaveDataV2();
}
```
  </action>
  <verify>Build compiles and links: `cd pokefirered && make -j4 2>&1 | tail -20` (check for success, no undefined references)</verify>
  <done>All section-aware accessors implemented, existing global accessors updated to use current section</done>
</task>

</tasks>

<verification>
1. `sizeof(struct QuizSaveDataV2) <= 400` (STATIC_ASSERT passes)
2. `cd pokefirered && make -j4` builds without errors
3. Section-aware functions compile and link
4. Existing Quiz_GetMasteryMask/Quiz_SetMasteryMask calls continue to work (use current section)
</verification>

<success_criteria>
- QuizSaveDataV2 struct occupies unused_348C space (386 of 400 bytes)
- sectionCleared[8][20] tracks 160 species × 8 sections as bits
- masteryMask[8][28] tracks mastery with modulo-28 slots per section
- Quiz_MigrateSaveData handles V1→V2 migration
- Existing global accessors now internally use current section
- Build compiles and links without errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-map-questions-to-encounters/14-02-SUMMARY.md`
</output>
