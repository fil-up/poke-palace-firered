---
phase: 04-core-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pokefirered/src/quiz/quiz.c
autonomous: true
must_haves:
  truths:
    - "Questions already mastered are not repeated"
    - "All questions mastered triggers CAPTURE_PENDING state"
    - "State persists in save data"
  artifacts:
    - Modified Quiz_InitWildEncounter with mastery filtering
  key_links:
    - "masteryMask bits correspond to question indices in bank"
---

<objective>
Enhance the quiz core loop to filter out already-mastered questions and detect when all questions for a species are complete, transitioning to CAPTURE_PENDING state.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@pokefirered/src/quiz/quiz.c

Current State (Phase 3 complete):
- Quiz_InitWildEncounter selects random question from bank
- Correct answer sets bit in masteryMask via Quiz_SetMasteryMask
- QuizSpeciesState enum has NONE, MASTERING, CAPTURE_PENDING, CLEARED

Needed:
- Filter question selection to skip questions with bit already set
- Count unmastered questions; if 0, set state to CAPTURE_PENDING
- On encounter, check state - if CAPTURE_PENDING, handle differently (Phase 5)

Note: LOOP-02 (correct answer sets bit) already implemented in Phase 3.
</context>

<tasks>
<task type="auto">
  <name>Add helper to count unmastered questions</name>
  <files>pokefirered/src/quiz/quiz.c</files>
  <action>
Add static helper function:

```c
// Count how many questions are NOT yet mastered for this species
static u8 Quiz_CountUnmasteredQuestions(u16 species, const struct QuizBank *bank)
{
    u8 mask, count, i;
    
    if (bank == NULL || bank->count == 0)
        return 0;
    
    mask = Quiz_GetMasteryMask(species);
    count = 0;
    
    for (i = 0; i < bank->count && i < 8; i++)
    {
        if (!(mask & (1 << i)))
            count++;
    }
    
    return count;
}
```
  </action>
  <verify>Function compiles</verify>
  <done>Helper function counts questions not in mastery mask</done>
</task>

<task type="auto">
  <name>Add helper to select unmastered question</name>
  <files>pokefirered/src/quiz/quiz.c</files>
  <action>
Add static helper function:

```c
// Select a random unmastered question, returns index or 0xFF if none
static u8 Quiz_SelectUnmasteredQuestion(u16 species, const struct QuizBank *bank)
{
    u8 mask, unmasteredCount, targetIndex, i, found;
    
    if (bank == NULL || bank->count == 0)
        return 0xFF;
    
    mask = Quiz_GetMasteryMask(species);
    unmasteredCount = Quiz_CountUnmasteredQuestions(species, bank);
    
    if (unmasteredCount == 0)
        return 0xFF;  // All mastered
    
    // Pick random unmastered question
    targetIndex = Random() % unmasteredCount;
    found = 0;
    
    for (i = 0; i < bank->count && i < 8; i++)
    {
        if (!(mask & (1 << i)))
        {
            if (found == targetIndex)
                return i;
            found++;
        }
    }
    
    return 0xFF;  // Shouldn't reach here
}
```
  </action>
  <verify>Function compiles</verify>
  <done>Helper selects random question from unmastered pool</done>
</task>

<task type="auto">
  <name>Update Quiz_InitWildEncounter with mastery filtering</name>
  <files>pokefirered/src/quiz/quiz.c</files>
  <action>
Replace the question selection logic in Quiz_InitWildEncounter:

```c
void Quiz_InitWildEncounter(u16 species, u8 mapGroup, u8 mapNum)
{
    const struct QuizBank *bank;
    u8 state;
    u8 questionIndex;

    sQuizState.active = FALSE;
    sQuizState.lastHoverIndex = 0xFF;
    sQuizState.turnResult = QUIZ_TURN_NONE;
    sQuizState.currentQuestion = NULL;
    sQuizState.currentSpecies = species;
    sQuizState.currentQuestionIndex = 0;

    // Check current state
    state = Quiz_GetSpeciesState(species);
    
    // If already cleared, no quiz
    if (state == QUIZ_STATE_CLEARED)
        return;
    
    bank = Quiz_GetBank(species);
    if (bank == NULL || bank->count == 0)
        return;
    
    // If CAPTURE_PENDING, will be handled in Phase 5
    // For now, just skip quiz
    if (state == QUIZ_STATE_CAPTURE_PENDING)
        return;
    
    // Select unmastered question
    questionIndex = Quiz_SelectUnmasteredQuestion(species, bank);
    
    if (questionIndex == 0xFF)
    {
        // All questions mastered! Transition to CAPTURE_PENDING
        Quiz_SetSpeciesState(species, QUIZ_STATE_CAPTURE_PENDING);
        return;
    }
    
    // Set state to MASTERING if not already
    if (state == QUIZ_STATE_NONE)
        Quiz_SetSpeciesState(species, QUIZ_STATE_MASTERING);
    
    sQuizState.currentQuestion = bank->questions[questionIndex];
    sQuizState.currentQuestionIndex = questionIndex;
    sQuizState.active = TRUE;

    (void)mapGroup;
    (void)mapNum;
}
```
  </action>
  <verify>Build succeeds, answered questions don't repeat</verify>
  <done>
- Questions filtered by mastery mask
- All-mastered transitions to CAPTURE_PENDING
- State set to MASTERING on first encounter
  </done>
</task>

<task type="auto">
  <name>Check for all-mastered after correct answer</name>
  <files>pokefirered/src/quiz/quiz.c</files>
  <action>
In Quiz_OnMoveConfirmed, after setting the mastery bit, check if all questions are now mastered:

```c
if (moveSlot == sQuizState.currentQuestion->correctIndex)
{
    u8 mask;
    const struct QuizBank *bank;
    
    sQuizState.turnResult = QUIZ_TURN_CORRECT;
    
    // Update mastery - set bit for this question
    mask = Quiz_GetMasteryMask(sQuizState.currentSpecies);
    mask |= (1 << sQuizState.currentQuestionIndex);
    Quiz_SetMasteryMask(sQuizState.currentSpecies, mask);
    
    // Check if all questions now mastered
    bank = Quiz_GetBank(sQuizState.currentSpecies);
    if (Quiz_CountUnmasteredQuestions(sQuizState.currentSpecies, bank) == 0)
    {
        Quiz_SetSpeciesState(sQuizState.currentSpecies, QUIZ_STATE_CAPTURE_PENDING);
    }
}
```
  </action>
  <verify>Answering final question correctly sets CAPTURE_PENDING</verify>
  <done>
- All-mastered check after each correct answer
- Immediate transition to CAPTURE_PENDING when complete
  </done>
</task>
</tasks>

<verification>
1. `make` compiles without errors
2. First encounter: random question shown
3. Answer correctly, encounter again: different question
4. After answering all questions correctly: state = CAPTURE_PENDING
5. CAPTURE_PENDING encounter: quiz not shown (Phase 5 will handle)
</verification>

<success_criteria>
- Questions don't repeat once answered correctly
- State transitions: NONE → MASTERING → CAPTURE_PENDING
- Mastery persists across save/load
</success_criteria>
