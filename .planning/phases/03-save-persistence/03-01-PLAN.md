---
phase: 03-save-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pokefirered/include/global.h
  - pokefirered/include/quiz/quiz.h
  - pokefirered/src/quiz/quiz.c
  - pokefirered/src/new_game.c
autonomous: true
must_haves:
  truths:
    - "Quiz mastery data persists across save/load"
    - "New game initializes quiz save data to zero"
    - "Correct answers update mastery bitmask"
  artifacts:
    - QuizSaveData struct in global.h
    - Quiz save functions in quiz.c
  key_links:
    - "gSaveBlock1Ptr->quizData accessed by quiz functions"
---

<objective>
Add quiz mastery persistence to the save system. Store per-species question mastery bitmasks and encounter states in SaveBlock1, allowing progress to survive save/load cycles.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@pokefirered/include/global.h (SaveBlock1 struct, lines 759-822)

SaveBlock1 has unused space:
- `unused_348C[400]` - 400 bytes available at offset 0x348C

Quiz save data needs:
- Per species: mastery bitmask (u8) - which questions answered correctly
- Per species: encounter state (u8) - NONE/MASTERING/CAPTURE_PENDING/CLEARED
- Version field for future migrations

With 7 initial species, need ~14 bytes. Design for growth to ~50 species = 100 bytes.
Will use a fixed-size array within the 400-byte unused space.
</context>

<tasks>
<task type="auto">
  <name>Define QuizSaveData structure</name>
  <files>pokefirered/include/global.h</files>
  <action>
Add before SaveBlock1 definition:

```c
// Quiz mastery save data
#define QUIZ_SAVE_MAX_SPECIES 64

enum QuizSpeciesState
{
    QUIZ_STATE_NONE = 0,       // Species not encountered
    QUIZ_STATE_MASTERING,      // Answering questions
    QUIZ_STATE_CAPTURE_PENDING,// All questions mastered, ready for capture
    QUIZ_STATE_CLEARED,        // Species captured/completed
};

struct QuizSpeciesSave
{
    u8 masteryMask;   // Bitmask of mastered questions (up to 8)
    u8 state;         // QuizSpeciesState
};

struct QuizSaveData
{
    u8 version;       // Save format version for migrations
    u8 padding;
    struct QuizSpeciesSave species[QUIZ_SAVE_MAX_SPECIES];
    // Total: 2 + (64 * 2) = 130 bytes, fits in unused_348C
};
```

In SaveBlock1, replace part of unused_348C:
```c
/*0x348C*/ struct QuizSaveData quizData;
/*0x350E*/ u8 unused_350E[270]; // Reduced from 400 to 270
```
  </action>
  <verify>Compile with `make` - no size errors</verify>
  <done>
- QuizSaveData struct defined
- Added to SaveBlock1 in place of unused space
- Save size unchanged (still 0x3D68)
  </done>
</task>

<task type="auto">
  <name>Add quiz save accessor functions</name>
  <files>
pokefirered/include/quiz/quiz.h
pokefirered/src/quiz/quiz.c
  </files>
  <action>
Add to quiz.h:
```c
// Save data accessors
void Quiz_InitSaveData(void);
u8 Quiz_GetMasteryMask(u16 species);
void Quiz_SetMasteryMask(u16 species, u8 mask);
u8 Quiz_GetSpeciesState(u16 species);
void Quiz_SetSpeciesState(u16 species, u8 state);
```

Implement in quiz.c:
```c
#include "global.h"  // For gSaveBlock1Ptr

// Species ID to save index mapping (simple for now)
static u8 Quiz_GetSaveIndex(u16 species)
{
    // Map species to a save slot (0-63)
    // For MVP, use lower bits of species ID
    return species % QUIZ_SAVE_MAX_SPECIES;
}

void Quiz_InitSaveData(void)
{
    memset(&gSaveBlock1Ptr->quizData, 0, sizeof(struct QuizSaveData));
    gSaveBlock1Ptr->quizData.version = 1;
}

u8 Quiz_GetMasteryMask(u16 species)
{
    u8 index = Quiz_GetSaveIndex(species);
    return gSaveBlock1Ptr->quizData.species[index].masteryMask;
}

void Quiz_SetMasteryMask(u16 species, u8 mask)
{
    u8 index = Quiz_GetSaveIndex(species);
    gSaveBlock1Ptr->quizData.species[index].masteryMask = mask;
}

u8 Quiz_GetSpeciesState(u16 species)
{
    u8 index = Quiz_GetSaveIndex(species);
    return gSaveBlock1Ptr->quizData.species[index].state;
}

void Quiz_SetSpeciesState(u16 species, u8 state)
{
    u8 index = Quiz_GetSaveIndex(species);
    gSaveBlock1Ptr->quizData.species[index].state = state;
}
```
  </action>
  <verify>Functions compile without errors</verify>
  <done>
- Save accessor functions added to quiz.h
- Implementation in quiz.c
- Uses gSaveBlock1Ptr for persistence
  </done>
</task>

<task type="auto">
  <name>Initialize quiz data on new game</name>
  <files>pokefirered/src/new_game.c</files>
  <action>
Find the NewGameInitData or similar function that initializes SaveBlock1.
Add call to Quiz_InitSaveData() after other initialization.

```c
#include "quiz/quiz.h"

// In the new game init function:
Quiz_InitSaveData();
```
  </action>
  <verify>Start new game, verify quizData.version == 1</verify>
  <done>
- Quiz_InitSaveData called on new game
- Save data properly zeroed
  </done>
</task>

<task type="auto">
  <name>Update quiz to track mastery on correct answer</name>
  <files>pokefirered/src/quiz/quiz.c</files>
  <action>
In Quiz_OnMoveConfirmed, after setting QUIZ_TURN_CORRECT:
- Get current mastery mask
- Set the bit for the current question
- Save the updated mask

Need to track which question index we're on. Add to QuizState:
```c
u8 currentQuestionIndex;  // Index within the bank
```

Update Quiz_InitWildEncounter to store the index.

Update Quiz_OnMoveConfirmed:
```c
if (moveSlot == sQuizState.currentQuestion->correctIndex)
{
    u8 mask;
    sQuizState.turnResult = QUIZ_TURN_CORRECT;
    
    // Update mastery
    mask = Quiz_GetMasteryMask(sQuizState.currentSpecies);
    mask |= (1 << sQuizState.currentQuestionIndex);
    Quiz_SetMasteryMask(sQuizState.currentSpecies, mask);
}
```
  </action>
  <verify>Answer correctly, check mask updated via debugger or test</verify>
  <done>
- Correct answer updates mastery mask
- Bit set corresponds to question index
  </done>
</task>
</tasks>

<verification>
1. `make` compiles without errors or size changes
2. New game initializes quizData with version=1
3. Correct answer sets bit in mastery mask
4. Save game, reload, verify mask persisted
</verification>

<success_criteria>
- Quiz mastery data stored in SaveBlock1
- New games initialize quiz data properly
- Correct answers update persistent mastery mask
- Data survives save/load cycle
</success_criteria>
